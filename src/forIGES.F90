! This file is part of the forIGES library
! https://github.com/rweed/forIGES

! Copyright (C) 2024 Richard Weed.
! All rights reserved.

! Redistribution and use in source and binary forms, with or without 
! modification, are permitted provided that the following conditions are met:

! 1. Redistributions of source code, in whole or in part, must retain the  
! above copyright notice, this list of conditions and the following 
! disclaimer.

! 2. Redistributions in binary form, in whole or in part, must reproduce the 
! above copyright notice, this list of conditions and the following disclaimer 
! in the documentation and/or other materials provided with the distribution.

! 3. The names of the contributors may not be used to endorse or promote from 
! products derived from this software without specific prior written 
! permission.

! 4. Redistribution of this source code, including any modifications, may 
! not be intentionally obfuscated.

! THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
! IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
! THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
! PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS AND
! CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
! EXEMPLARARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
! PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; 
! OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
! WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR 
! OTHERWISE), ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
! ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Module forIGES 
!! Modern Fortran utilities and types for performing IO of IGES file geometry
!! and related entities generated by CAD programs. It is NOT a complete IGES
!! file reader and focuses primarily on geometric entities and skips most
!! drawing and viewing entities 

!! Author  : Richard Weed

!! Version : 0.1 (Beta release 1)
!! Date    : August 18, 2024

  USE IGES_params
  USE IGES_utils
  USE IGES_Gsection
  USE IGES_Dsection
  USE IGES_Psection
  USE DElist, ONLY: DElist_t, DEnode_t
  USE PElist, ONLY: PElist_t, PEnode_t
 
  Implicit NONE

!  PRIVATE

  Type :: IGES_t
!! IGES_t defines an in-memory representation of both the original IGES file
!! and all the entities and other data required to read and/or write an 
!! IGES CAD model
 
   Character(80), Allocatable :: fileImage(:)
   !! An array of 80 character records that defines an in-memory image of the
   !! input IGES file 
   Character(:),  Allocatable :: filename
   !! Name of input IGES file
   Integer                    :: numSrecs = 0
   !! Number of S section records in file
   Integer                    :: numGrecs = 0 
   !! Number of G section records in file
   Integer                    :: numDrecs = 0
   !! Number of D section records in file
   Integer                    :: numPrecs = 0
   !! Number of P section records in file
   Integer                    :: nentities = 0
   !! Total number of individual entities in file
   Integer                    :: nse       = 0
   !! Number of supported entities in file

   Logical                    :: compressed_input  = .FALSE.
   !! Is input data compressed ascii - probably will never be used
   Logical                    :: compressed_output = .FALSE.
   !! Is output data compressed ascii - probably will never be used

   Integer,       Allocatable :: model_entities(:)
   !! Array of model entity numbers in file 
   Character(80), Allocatable :: Srecords(:)
   !! Array containing the S section records
   Character(80), Allocatable :: Grecords(:)
   !! Array containing the G section records
   Character(80), Allocatable :: Drecords(:)
   !! Array containing the D section records
   Character(80), Allocatable :: Precords(:)
   !! Array containing the P section records
   Character(80)              :: Trecord
   !! The termination record
   Integer,       Allocatable :: param_start(:)
   !! Starting sequence number in parameter section of an entity
   Integer,       Allocatable :: param_end(:)
   !! Ending sequence number in parameter section of an entity
   Type(Gsection_t)           :: G
   !! A Gsection_t type to hold Gsection values
   Type(Dsection_t)           :: D
   !! A Dsection_t type to hold an array of Dictionary Section entries
   Type(Psection_t)           :: P
   !! A Psection_t type to hold an array of polymorphic P entities
   Type(PElist_t)             :: PElist
   !! A PElist type
   Type(DElist_t)             :: DElist
   !! A DElist type
  
  Contains

    Procedure :: makeFileimage
    !! makes an in memory image of an IGES file
    Procedure :: splitFileimage
    !! Splits the file image into separate S, G, D, and P section arrays
    Procedure :: makeIGESfile
    !! Makes a complete IGES file from current IGES_t S, G, D, P sections
    Procedure :: makeSrecs
    !! Makes an array of S section records
    Procedure :: getG
    !! Creates a Gsection_t type from input records
    Procedure :: getD
    !! Creates a Dsection_t type and arrays from input records
    Procedure :: getP
    !! Creates a Psection_t type and arrays from input records 
    Procedure :: createIGESfromRecs
    !! Creates a new IGES_t object from user supplied S, G, D, and P section
    !! Character arrays
    Procedure :: makePElist
    !! Makes a list of P entities
    Procedure :: makeDElist
    !! Makes a list of D entries
    Procedure :: setPtmatForm
    !! sets the tmat and form values in a P entity based on its DE values
    Procedure :: readFile  => readIGESfile
    !! Reads an IGES file and creates an IGES_t model
    Procedure :: output    => outputIGESmodel
    !! Outputs an IGES_t models section component values to an user specified
    !! file
    Procedure :: dealloc   => deallocIGES
    !! Deallocates and resets an IGES_t model components

  End Type

  Interface makePrecs 
  !! Generic interface for makePrec routines 
    Module Procedure makePrecList 
    Module Procedure makePrecArr
  End Interface

  Interface makeDrecs
  !! Generic interface for makeDrec routines 
    Module Procedure makeDrecPlist
    Module Procedure MakeDrecParr
  End Interface

  Interface makeDPsections
  !! Generic interface for makeDPsection routines 
    Module Procedure makeDPsecPlist
    Module Procedure makeDPsecParr
    Module Procedure makeDPsecDPlists
  End Interface

  Interface filterDPlists
  !! Extracts user defined entity types from given DE and PE lists and returns
  !! new DE and PE lists
    Module Procedure filterListsByType
    Module Procedure filterListsByTypes
  End Interface

  Interface filterDParrays
  !! Extracts user defined entity types from given DE and PE arrays and returns
  !! new DE and PE lists
    Module Procedure filterArraysByType
    Module Procedure filterArraysByTypes
  End Interface

!  Public :: IGES_t, copyParrayToList, copyPlistToArray, copyDarrayToList,     &
!            copyDlistToArray, makePrecs, makeDrecs, makeDPsections,           &
!            makeGsection, makeSsection, writeIGESfile, filterDPlists,         &
!            filterDParrays

Contains

  Subroutine deallocIGES(this)
  !! Deallocates and resets the components of an IGES_t class

    Class(IGES_t), INTENT(INOUT) :: this
    !! This IGES_t passed argument

    Integer :: i

    If (ALLOCATED(this%fileImage)) DEALLOCATE(this%fileImage) 
    If (ALLOCATED(this%filename))  DEALLOCATE(this%filename)

    this%numSrecs  = 0
    this%numGrecs  = 0 
    this%numDrecs  = 0
    this%numPrecs  = 0

    this%compressed_input  = .FALSE.
    this%compressed_output = .FALSE.

    If (ALLOCATED(this%model_entities)) DEALLOCATE(this%model_entities)
    If (ALLOCATED(this%Srecords))       DEALLOCATE(this%Srecords)
    If (ALLOCATED(this%Grecords))       DEALLOCATE(this%Grecords)
    If (ALLOCATED(this%Drecords))       DEALLOCATE(this%Drecords)
    If (ALLOCATED(this%Precords))       DEALLOCATE(this%Precords)
    this%Trecord = REPEAT(" ",80)

    If (ALLOCATED(this%param_start)) DEALLOCATE(this%param_start)
    If (ALLOCATED(this%param_end))   DEALLOCATE(this%param_end)

    Call this%G%dealloc()
    Call this%D%dealloc()
    Do i=1,this%nse
      Call this%P%PE(i)%entity%dealloc()
    End Do
    If (ALLOCATED(this%P%PE)) DEALLOCATE(this%P%PE)
    this%nentities = 0

  End Subroutine deallocIGES 

  Subroutine makeFileImage(this)
  !! Reads an IGES ASCII input file and copies the entire file into a memory
  !! resident file image array

    Class(IGES_t), Intent(INOUT) :: this
    !! This IGES_t passed argument

    Integer                   :: i, funit, numrecs, istat, idot
    Character(80)             :: buffer
    Character(1)              :: dum
    Character(:), Allocatable :: compressed_filename
    Character(:), Allocatable :: new_filename
    Logical :: isOpen, exists

!  First check if file exists

    INQUIRE(FILE= TRIM(ADJUSTL(this%filename)), EXIST=exists, OPENED=isOpen,   &
            NUMBER=funit) 

    If (.NOT.exists) Then

      error stop " Requested IGES file not found"
   
    Else If (isOpen) Then

      REWIND(funit)
     
    Else

      Open(newunit=funit,FILE=TRIM(ADJUSTL(this%filename)), FORM="FORMATTED",  &
           STATUS = "UNKNOWN")
    End If

! Check for compressed ASCII file and convert it to old format prior to
! processing

    Read(funit,'(A)') buffer
    If (buffer(73:73) == "C") Then
      this%compressed_input = .TRUE.
      compressed_filename   = this%filename
      idot                  = INDEX(compressed_filename,".ig")
      new_filename          = compressed_filename(1:idot-1)//"_uncompressed.igs"
      Close(funit) 
      Call convertCompToOldIGES(compressed_filename, new_filename) 
      Open(newunit=funit,FILE=TRIM(ADJUSTL(new_filename)), FORM="FORMATTED",  &
           STATUS = "UNKNOWN")
    Else
      REWIND(funit)
    End If

! next count number of records in file 

    numrecs = 0
    COUNTRECS: Do
      Read(funit, '(A1)', IOSTAT=istat) dum 
      If (istat /= 0) EXIT COUNTRECS
      numrecs = numrecs+1
    End Do COUNTRECS 
    
    ALLOCATE(this%fileImage(numrecs))
      
    REWIND(funit)

! Read file records into file image array

    READRECS: Do i=1,numrecs
      this%fileImage(i) = REPEAT(" ",80)
      Read(funit,'(A80)') this%fileImage(i)
    End Do READRECS

    Close(funit)

  End Subroutine makeFileImage

  Subroutine makeIGESfile(this, filename, overwrite)
  !! Creates a complete IGES file with the given filename. An existing file
  !! will be overwritten if the optional overwrite argument is set to .TRUE.
  !! Otherwise an error stop will occur.
 
    Class(IGES_t),          Intent(IN) :: this
    Character(*),           Intent(IN) :: filename
    Logical,      Optional, Intent(IN) :: overwrite

    Integer :: i, funit
    Logical :: over, isOpen, exists

    over = .FALSE.

    If (PRESENT(overwrite)) over = overwrite

!  First check if file exists

    INQUIRE(FILE= TRIM(ADJUSTL(filename)), EXIST=exists, OPENED=isOpen,       &
            NUMBER=funit) 


    If (exists) Then
      If (over) Then
        Print *, " Requested IGES file already exists and will be overwritten"
        REWIND(funit) 
      Else
        error stop " Attempting to overwrite existing IGES file with overwrite =.FALSE."
      End If
    Else

      Open(newunit=funit,FILE=TRIM(ADJUSTL(filename)), FORM="FORMATTED",       &
           STATUS = "UNKNOWN")
    End If

! Write S section

   Do i=1, this%numSrecs 
     Write(funit,'(A80)') this%Srecords(i)
   End Do

! Write G section

   Do i=1, this%numGrecs
     Write(funit,'(A80)') this%Grecords(i)
   End Do
 
! Write D section

   Do i=1, this%numDrecs
     Write(funit,'(A80)') this%Drecords(i)
   End Do
 
! Write P section

   Do i=1, this%numPrecs
     Write(funit,'(A80)') this%Precords(i)
   End Do
 
! Write T section

   Write(funit,'(A80)') this%Trecord

   Close(funit)
 
  End Subroutine makeIGESfile

  Subroutine splitFileImage(this, keepImage)
  !! Splits the input fileimage into separate arrays of S, G, D, and P
  !! section records. The file image is deleted here unless the optional
  !! keepImage argument is set to .TRUE.

    Class(IGES_t),     Intent(INOUT) :: this
    !! this IGES_t passed argument
    Logical, Optional, Intent(IN)    :: keepImage
    !! Optional argument for keeping the file image if set to .TRUE.

    Integer :: i, nrecs, irec

    Logical :: keep

    keep = .FALSE.

    If (PRESENT(keepImage)) keep = keepImage
 
    If (.NOT. ALLOCATED(this%fileImage)) Then
      error stop " IGES file image has not been maked"
    End If

    nrecs = SIZE(this%fileImage)

! Count number of records for each section

    Do i=1,nrecs-1
      If (this%fileImage(i)(73:73) == "S") Then
        this%numSrecs = this%numSrecs + 1
      End If  
      If (this%fileImage(i)(73:73) == "G") Then
        this%numGrecs = this%numGrecs + 1
      End If  
      If (this%fileImage(i)(73:73) == "D") Then
        this%numDrecs = this%numDrecs + 1
      End If  
      If (this%fileImage(i)(73:73) == "P") Then
        this%numPrecs = this%numPrecs + 1
      End If  
    End Do

    this%Trecord = this%fileImage(nrecs)

! Allocate space for each section records and then split each
! sections records off from file image

    ALLOCATE(this%Srecords(this%numSrecs))
    ALLOCATE(this%Grecords(this%numGrecs))
    ALLOCATE(this%Drecords(this%numDrecs))
    ALLOCATE(this%Precords(this%numPrecs))

    irec = 0
    If (this%compressed_input) irec=1

    Do i = 1, this%numSrecs
      irec = irec+1
      this%Srecords(i) = this%fileImage(irec)
    End Do

    Do i = 1, this%numGrecs
      irec = irec+1
      this%Grecords(i) = this%fileImage(irec)
    End Do

    Do i = 1, this%numDrecs
      irec = irec+1
      this%Drecords(i) = this%fileImage(irec)
    End Do
 
    Do i = 1, this%numPrecs
      irec = irec+1
      this%Precords(i) = this%fileImage(irec)
    End Do

    If (.NOT.keep) Then
      If (ALLOCATED(this%fileImage)) DEALLOCATE(this%fileImage)
    End if
   
  End Subroutine splitFileImage

  Subroutine makeSrecs(this, Srecords, newrecs)
  !! Creates an S section array of 80 character records from the input S
  !! records or from an optional newrecs array if present 
 
    Class(IGES_t),              Intent(IN)    :: this
    !! this IGES_t passed argument
    Character(80), Allocatable, Intent(INOUT) :: Srecords(:)
    !! Output S records array
    Character(80), Optional,    Intent(IN)    :: newrecs(:)
    !! Optional array of S records to be used in place of the input records
    !! stored in IGES_t

    Integer :: i, ns

!! make S records from either the current IGES_t values or user supplied
!! newrecs

    If (PRESENT(newrecs)) Then
      ns = SIZE(newrecs)
      ALLOCATE(Srecords(ns))
      Do i=1, ns
        Srecords(i)        = REPEAT(" ", 80)
        Srecords(i)(73:73) = "S"
        Write(Srecords(i)(74:80),'(i7)') i
        Srecords(i)(1:72)  = newrecs(i)(1:72)   
      End Do
    Else
      ns = SIZE(this%Srecords)
      ALLOCATE(Srecords(ns))
      Do i=1, ns
        Srecords(i)        = REPEAT(" ", 80)
        Srecords(i)(73:73) = "S"
        Write(Srecords(i)(74:80),'(i7)') i
        Srecords(i)(1:72)  = this%Srecords(i)(1:72)   
      End Do
    End If
 
  End Subroutine makeSrecs 

  Subroutine createIGESfromRecs(this, Srecords, Grecords, Drecords, Precords)

    Class(IGES_t),  Intent(INOUT) :: this
    Character(80),  Intent(IN)    :: Srecords(:)
    Character(80),  Intent(IN)    :: Grecords(:)
    Character(80),  Intent(IN)    :: Drecords(:)
    Character(80),  Intent(IN)    :: Precords(:)

    Character(80) :: Tsection
    Integer :: i, numS, numG, numD, numP
    
    numS = SIZE(Srecords)
    numG = SIZE(Grecords)
    numD = SIZE(Drecords)
    numP = SIZE(Precords)

    If (ALLOCATED(this%Srecords)) DEALLOCATE(this%Srecords)
    If (ALLOCATED(this%Grecords)) DEALLOCATE(this%Grecords)
    If (ALLOCATED(this%Drecords)) DEALLOCATE(this%Drecords)
    If (ALLOCATED(this%Precords)) DEALLOCATE(this%Precords)

    ALLOCATE(this%Srecords(numS))
    ALLOCATE(this%Grecords(numG))
    ALLOCATE(this%Drecords(numD))
    ALLOCATE(this%Precords(numP))

    this%Srecords = Srecords
    this%Grecords = Grecords
    this%Drecords = Drecords
    this%Precords = Precords

    Call this%getG()
    Call this%getD()
    Call this%getP()
    Call makeTsection(numS, numG, numD, numP, this%Trecord)

    Do i=1, numS
      this%Srecords(i)(73:80) = "       "
    End Do
  End Subroutine createIGESfromRecs

  Subroutine getG(this)
  !! Creates an IGES_T G section from the input G section records

    Class(IGES_t), Intent(INOUT) :: this
    !! this IGES_t passed argument

    Call this%G%getGS(this%Grecords)

  End Subroutine getG

  Subroutine getD(this)
  !! Creates the IGES_t D section type and arrays from the input D section
  !! records

    Class(IGES_t), Intent(INOUT) :: this
    !! this IGES_t passed argument

    Integer :: i, nd

    Call this%D%getDS(this%Drecords)

    nd             = this%D%nentries
    this%nentities = nd

    ALLOCATE(this%model_entities(nd))
     
    Do i=1, nd
      this%model_entities(i) = this%D%DE(i)%entity_type
    End Do

  End Subroutine getD

  Subroutine getP(this)
  !! Creates the IGES_t P section type and arrays from the input P section
  !! records
  
    Class(IGES_t), Intent(INOUT) :: this
    !! this IGES_t passed argument

    Integer     :: i, nentity, is, ie, ien, nse
    Integer     :: entity_type
    Integer     :: form

! set number of entities and number of supported entities

    nentity = this%nentities
    nse = 0
    Do i =1,nentity
      If (is_supported_entity(this%model_entities(i))) Then
        nse = nse+1
      End If
    End Do 

! allocate PE, param_start, and param_end arrays

    this%nse = nse
    ALLOCATE(this%P%PE(nentity))
    ALLOCATE(this%param_start(nentity), SOURCE=0)
    ALLOCATE(this%param_end(nentity),   SOURCE=0)

! Loop through number of entities extracting entity type, starting and
! ending sequence (record) numbers in Psection array and the add each
! entity to entity array. Unsupported P entities are set to the unsupported_t
! placeholder

    ien = 0
    Do i=1, nentity

      is   = this%D%DE(i)%param_data
      ie   = is + this%D%DE(i)%param_line_count - 1
      form = this%D%DE(i)%form_number

      entity_type         = this%model_entities(i)
      this%param_start(i) = is
      this%param_end(i)   = ie

! Use select case, local block constructs, and sourced allocation  to read
! data for a specific P entity from the IGES_t Precords array. Note the
! PE(i)%entity values are instances of an abstract type and you have to
! use sourced allocation to "convert" them to a concrete type. Each
! type is selected based on the current model_entities array values.
! ** Note: I could have probably used a Select Type construct here but I
! really times infinity hate Select Type

      Select Case(entity_type)

        Case(0)

          BLOCK
            Type(entity0_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(100)

          BLOCK
            Type(entity100_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(102)

          BLOCK
            Type(entity102_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(104)

          BLOCK
            Type(entity104_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(106)

          BLOCK
            Type(entity106_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(108)

          BLOCK
            Type(entity108_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(110)

          BLOCK
            Type(entity110_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(112)

          BLOCK
            Type(entity112_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(114)

          BLOCK
            Type(entity114_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(116)

          BLOCK
            Type(entity116_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(118)

          BLOCK
            Type(entity118_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(120)

          BLOCK
            Type(entity120_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(122)

          BLOCK
            Type(entity122_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(123)

          BLOCK
            Type(entity123_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(124)

          BLOCK
            Type(entity124_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(126)

          BLOCK
            Type(entity126_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(128)

          BLOCK
            Type(entity128_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(130)

          BLOCK
            Type(entity130_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(140)

          BLOCK
            Type(entity140_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(141)

          BLOCK
            Type(entity141_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(142)

          BLOCK
            Type(entity142_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(143)

          BLOCK
            Type(entity143_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(144)

          BLOCK
            Type(entity144_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK


        Case(190)

          BLOCK
            Type(entity190_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK


        Case(192)

          BLOCK
            Type(entity192_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(194)

          BLOCK
            Type(entity194_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(196)

          BLOCK
            Type(entity196_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(198)

          BLOCK
            Type(entity198_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(212)

          BLOCK
            Type(entity212_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(308)

          BLOCK
            Type(entity308_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(314)

          BLOCK
            Type(entity314_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(402)

          BLOCK
            Type(entity402_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(406)

          BLOCK
            Type(entity406_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(408)

          BLOCK
            Type(entity408_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(502)

          BLOCK
            Type(entity502_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(504)

          BLOCK
            Type(entity504_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(508)

          BLOCK
            Type(entity508_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case(510)

          BLOCK
            Type(entity510_t) :: entity
            Call entity%getEntity(this%Precords(is:ie), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

        Case Default

! Create a place holder for unsupported entities

          BLOCK
            Type(unsupported_t) :: entity
            Call entity%getEntity(this%Precords(is:is), form)
            ALLOCATE(this%P%PE(i)%entity, SOURCE=entity)
          End BLOCK

      End Select
    End Do

  End Subroutine getP
 
  Subroutine readIGESfile(this, filename)
  !! Reads an IGES file and creates an IGES_t type model

    Class(IGES_t),           Intent(INOUT) :: this
    !! This IGES_t passed argument
    Character(*),            Intent(IN)    :: filename
    !! IGES input file name

    this%filename = TRIM(ADJUSTL(filename))

! Read file into fileimage and split image into S, G, D, P record arrays
    Call this%makeFileimage()
    Call this%splitFileimage()

! Next convert section records into IGES_t components

    Call this%getG()
    Call this%getD()
    Call this%getP()
    
! Store transformation matrix number and form from directotry in P entities
! for backwards referencing

    Call this%setPtmatForm()

  End Subroutine readIGESfile

  Subroutine outputIGESmodel(this, filename)
!! Outputs a summary of the final entities contained in this IGES model to
!! either stdout or a user defined output unit. Both supported and unsupported
!! entities will be reported. 

    Class(IGES_t),          Intent(IN) :: this
    !! this IGES_t passed argument
    Character(*), Optional, Intent(IN) :: filename
    !! Optional output file name. If absent the output unit is set to stdout

    Integer :: i, ounit

! Set default output unit to stdout, otherwise open a new file using optional
! input file name

    ounit = stdout

    If (PRESENT(filename)) Then
      Open(newunit=ounit, FILE=TRIM(ADJUSTL(filename)), FORM="FORMATTED",    &
      STATUS="UNKNOWN")
    End If

    Write(ounit, *) ''
    Write(ounit, '(" ***** I G E S  M O D E L  D A T A ***** ")')
    Write(ounit, *) ''

    Write(ounit,'(" Model filename    : ", A)') TRIM(ADJUSTL(this%filename))
    Write(ounit, *) ''
    Write(ounit, '(" Number of records found in each IGES file section  : ")') 
    Write(ounit, *) ''
    Write(ounit, '(" Number of S section records = ",I0)') this%numSrecs
    Write(ounit, '(" Number of G section records = ",I0)') this%numGrecs
    Write(ounit, '(" Number of D section records = ",I0)') this%numDrecs
    Write(ounit, '(" Number of P section records = ",I0)') this%numPrecs
    Write(ounit,*) ' '
    Write(ounit, '(" S Section ")')
    Write(ounit,*) ' '
    Do i=1, this%numSrecs
      Write(ounit,'(" ",A)') TRIM(ADJUSTL(this%Srecords(i)))
    End Do

    Write(ounit,*) ''
    Call this%G%output(ounit)
    Write(ounit,*) ''
    Call this%D%output(ounit)

    Write(ounit,*) ''
    Write(ounit,'(" ***** I G E S  M O D E L  E N T I T I E S *****")')
    Write(ounit,*) ''
    Write(ounit,'(" There are ",i0," entities in this IGES model")') this%nentities
    Write(ounit,*) ''
    Do i = 1, this%nentities
      Write(ounit,*) ''
      Write(ounit,'(" IGES Model Entity no. : ",i0)') i
      Write(ounit,*) '' 
      Call this%P%PE(i)%entity%outputEntity(ounit)
    End Do
    Write(ounit,*) ''
    Write(ounit, '(" Termination Section : ", A)') TRIM(ADJUSTL(this%Trecord))  
    Write(ounit,*) ''

    FLUSH(ounit)
    If (ounit /= stdout) Close(ounit)

  End Subroutine outputIGESmodel

  Subroutine makeTsection(ns, ng, nd, np, Tsection)
  !! Makes the termination record

    Integer,       Intent(IN)    :: ns, ng, nd, np
    !! Input number of S, G, D, and P section records
    Character(80), Intent(INOUT) :: Tsection 
    !! Output Trecord string

    Integer :: i1

    i1 = 1
    Tsection = REPEAT(" ",80)

! Build the termination record based on number of records in each section

    Tsection(1:1)   = "S"
    Write(Tsection(2:8),  '(i7)') ns
    Tsection(9:9)   = "G"
    Write(Tsection(10:16),'(i7)') ng
    Tsection(17:17) = "D"
    Write(Tsection(18:24),'(i7)') nd
    Tsection(25:25) = "P"
    Write(Tsection(26:32),'(i7)') np
    Tsection(73:73) = "T"
    Write(Tsection(74:80),'(i7)') i1
 
  End Subroutine makeTsection  

  Subroutine makePrecList(PElist, Precords, param_start, param_end)
  !! Builds an array of 80 character P records from a given user list
    Class(PElist_t),            Target, Intent(INOUT) :: PElist 
    !! input P entity list
    Character(80), Allocatable,         Intent(INOUT) :: Precords(:)
    !! Output array of P records
    Integer,         Allocatable,        Intent(INOUT) :: param_start(:)
    !! Starting sequence number of each entity in P section
    Integer,         Allocatable,        Intent(INOUT) :: param_end(:)
    !! Ending   sequence number of each entity in P section

    Integer :: i, j, il, ntr, itr, np, ne

    Type(PEnode_t),  Pointer :: node 
    Type(records_t), Allocatable :: Precs(:)

! get size of list and initialize node

     ne   =  PElist%size()
     node => PElist%first()

! Allocate an array of the local Precs_t types

     ALLOCATE(Precs(ne))

! make the array of P records for each node in list
 
     Do i=1,ne
       Call node%PE%makeEntity(Precs(i)%recs)
       If (i<ne) Call PElist%move(node,1)
     End Do

! Set sequence number in columns 74 to 80 and the DE entry starting sequence
! number for this PE entry
 
     il = 0
     ALLOCATE(param_start(ne))
     ALLOCATE(param_end(ne))
     param_start(1) = 1
     Do i=1,ne
       np = SIZE(Precs(i)%recs)
       Do j=1,np
         il = il+1
         Write(Precs(i)%recs(j)(74:80), '(i7)') il
         Write(Precs(i)%recs(j)(66:72), '(i7)') (2*i-1)
       End Do
       param_end(i) = il
     End Do
     Do i=2,ne
       param_start(i) = param_end(i-1) + 1
     End Do

     ntr = 0
     Do i=1,ne
       np = SIZE(Precs(i)%recs)
       ntr = ntr + np
     End Do

! Now convert Parray records into the output Precords array

     ALLOCATE(Precords(ntr))

     itr = 0
     Do i = 1, ne
       np = SIZE(Precs(i)%recs)
       Do j= 1,np
         itr = itr + 1
         Precords(itr) = Precs(i)%recs(j)
       End Do
    End Do

    Do i=1,ne
      DEALLOCATE(Precs(i)%recs)
    End Do
    DEALLOCATE(Precs)
    NULLIFY(node)

  End Subroutine makePrecList
 
  Subroutine makePrecArr(PE, Precords, param_start, param_end)
  !! Builds an array of 80 character P records from a given user list and
  !! the this IGES_t passed argument

    Type(PE_t),                  Target, Intent(IN)    :: PE(:) 
    !! input P entity list
    Character(80),   Allocatable,        Intent(INOUT) :: Precords(:)
    !! Output array of P records
    Integer,         Allocatable,        Intent(INOUT) :: param_start(:)
    !! Starting sequence number of each entity in P section
    Integer,         Allocatable,        Intent(INOUT) :: param_end(:)
    !! Ending sequence number of each entity in P section

    Integer :: i, j, il, ntr, itr, np, ne

    Type(records_t), Allocatable :: Precs(:)

! get size of list and initialize node
     ne   =  SIZE(PE) 

! Allocate an array of the local Precs_t types

     ALLOCATE(Precs(ne))

! make the array of P records for each node in list
 
     Do i=1,ne
       Call PE(i)%entity%makeEntity(Precs(i)%recs)
     End Do

! Set sequence number in columns 74 to 80 and the DE entry starting sequence
! number for this PE entry
 
     il = 0
     ALLOCATE(param_start(ne))
     ALLOCATE(param_end(ne))
     param_start(1) = 1
     Do i=1,ne
       np = SIZE(Precs(i)%recs)
       Do j=1,np
         il = il+1
         Write(Precs(i)%recs(j)(74:80), '(i7)') il
         Write(Precs(i)%recs(j)(66:72), '(i7)') (2*i-1)
       End Do
       param_end(i) = il
     End Do
     Do i=2,ne
       param_start(i) = param_end(i-1) + 1
     End Do

     ntr = 0
     Do i=1,ne
       np = SIZE(Precs(i)%recs)
       ntr = ntr + np
     End Do

! Now convert Parray records into the output Precords array

     ALLOCATE(Precords(ntr))

     itr = 0
     Do i = 1, ne
       np = SIZE(Precs(i)%recs)
       Do j= 1,np
         itr = itr + 1
         Precords(itr) = Precs(i)%recs(j)
       End Do
    End Do

    Do i=1,ne
      DEALLOCATE(Precs(i)%recs)
    End Do
    DEALLOCATE(Precs)

  End Subroutine makePrecArr
 
  Subroutine makeDrecPlist(DE, PElist, Drecords, param_start, param_end)
  !! Make an array of 80 character D records from a given array of Dentry_t
  !! values and a parameter entity list.

    Type(Dentry_t), Allocatable, Intent(INOUT) :: DE(:)
    !! Array of DE entries for this model
    Type(PElist_t), Target,      Intent(INOUT) :: PElist
    !! A list of Parameter entitity values
    Character(80),  Allocatable, Intent(INOUT) :: Drecords(:)
    !! Output array of D records
    Integer,         Allocatable,        Intent(INOUT) :: param_start(:)
    !! Starting sequence number of each entity in P section
    Integer,         Allocatable,        Intent(INOUT) :: param_end(:)
    !! Ending sequence number of each entity in P section
 
    Integer     :: i, ne, iseq, ir, nr
    Integer     :: tmat
 
    Character(80) :: Drecs(2)
 
    Type(PEnode_t), Pointer :: node
   
! Generate D section records from dentries array  

    ne = PElist%size()
    nr = 2*ne

    If (.NOT. ALLOCATED(DE)) Then
      ALLOCATE(DE(ne))
    Else
      If (SIZE(DE) /= ne) Then
        Write(stderr,*)''
        Write(stderr,'(" makeDrecords: Size of DE argument is not ", &
    & " the same as the number of entities in list")') 
        Write(stderr,*)''
        STOP
      End If
    End If

    node => PElist%first()
    iseq = 1
    Do i=1,ne
      DE(i)%entity_type      = node%PE%entity_type
      DE(i)%param_data       = param_start(i)
      DE(i)%param_line_count = param_end(i) -             &
                               param_start(i) + 1
      If (DE(i)%transformation_matrix == 0) Then
        If (node%PE%tmat /= 0) Then
          tmat = 2*node%PE%tmat - 1
        Else
          tmat = 0
        End If
        DE(i)%transformation_matrix = tmat
      End If 
      DE(i)%sequence_number  = iseq
      If (DE(i)%form_number == 0) Then
        If (node%PE%form /= 0) Then 
          DE(i)%form_number = node%PE%form
        End If
      End If
      
      DE(i)%entity_label    = node%PE%entity_label
      iseq = iseq+2
      Call PElist%move(node,1)
    End Do

    ALLOCATE (Drecords(nr))
    ir = 1
    Do i = 1, ne
      Call DE(i)%makeDErecs(Drecs)
      Drecords(ir)   = Drecs(1)   
      Drecords(ir+1) = Drecs(2)
      ir = ir + 2
    End Do   

    NULLIFY(node)

  End Subroutine makeDrecPlist

  Subroutine makeDrecPArr(DE, PE, Drecords, param_start, param_end)
  !! Make an array of 80 character D records from a given array of Dentry_t
  !! values and an array of parameter entities 

    Type(Dentry_t), Allocatable, Intent(INOUT) :: DE(:)
    !! Array of DE entries for this model
    Type(PE_t),     Target,      Intent(IN)    :: PE(:)
    !! A list of Parameter entitity values
    Character(80),  Allocatable, Intent(INOUT) :: Drecords(:)
    !! Output array of D records
    Integer,         Allocatable,        Intent(INOUT) :: param_start(:)
    !! Starting sequence number of each entity in P section
    Integer,         Allocatable,        Intent(INOUT) :: param_end(:)
    !! Ending sequence number of each entity in P section
 
    Integer     :: i, ne, iseq, ir, nr
    Integer     :: tmat
 
    Character(80) :: Drecs(2)
 
! Generate D section records from dentries array  

    ne = SIZE(PE) 
    nr = 2*ne

    If (.NOT. ALLOCATED(DE)) Then
      ALLOCATE(DE(ne))
    Else
      If (SIZE(DE) /= ne) Then
        Write(stderr,*)''
        Write(stderr,'(" makeDrecords: Size of DE argument is not ", &
    & " the same as the number of entities in list")') 
        Write(stderr,*)''
        STOP
      End If
    End If

    iseq = 1
    Do i=1,ne
      DE(i)%entity_type      = PE(i)%entity%entity_type
      DE(i)%param_data       = param_start(i)
      DE(i)%param_line_count = param_end(i) -             &
                               param_start(i) + 1
      If (DE(i)%transformation_matrix == 0) Then
        If (PE(i)%entity%tmat /= 0) Then
          tmat = 2*PE(i)%entity%tmat - 1
        Else
          tmat = 0
        End If
        DE(i)%transformation_matrix = tmat
      End If 
      DE(i)%sequence_number  = iseq
      If (DE(i)%form_number == 0) Then
        If (PE(i)%entity%form /= 0) Then 
          DE(i)%form_number = PE(i)%entity%form
        End If
      End If
      
      DE(i)%entity_label = PE(i)%entity%entity_label
      iseq = iseq+2
    End Do

    ALLOCATE (Drecords(nr))
    ir = 1
    Do i = 1, ne
      Call DE(i)%makeDErecs(Drecs)
      Drecords(ir)   = Drecs(1)   
      Drecords(ir+1) = Drecs(2)
      ir = ir + 2
    End Do   

  End Subroutine makeDrecParr

  Subroutine makeDPsecDPlists(DElist, PElist, Dsection, Psection)
  !! Make the IGES output file D, and P sections from a Dentry list and
  !! a list  of PE entities. The Denty list will be converted to an array.

    Type(DElist_t),             Intent(INOUT) :: DElist
    Type(PElist_t),             Intent(INOUT) :: PElist
    Character(80), Allocatable, Intent(INOUT) :: Dsection(:)
    Character(80), Allocatable, Intent(INOUT) :: Psection(:)

    Integer, Allocatable :: param_start(:)
    ! Starting sequence number of each entity in P section
    Integer, Allocatable :: param_end(:)
    ! Ending sequence number of each entity in P section

    Type(Dentry_t), ALLOCATABLE :: DE(:)

    Call copyDlistToArray(DElist, DE)
    Call makePrecs(PElist,     Psection, param_start, param_end)
    Call makeDrecs(DE, PElist, Dsection, param_start, param_end)

  End Subroutine makeDPsecDPlists

  Subroutine makeDPsecPlist(DE, PElist, Dsection, Psection) 
  !! Make the IGES output file D, and P sections from a Dentry array and
  !! a list  of PE entities.  

    Type(Dentry_t), Allocatable, Intent(INOUT) :: DE(:)
    Type(PElist_t),              Intent(INOUT) :: PElist
   
    Character(80),  Allocatable, Intent(INOUT) :: Dsection(:)
    Character(80),  Allocatable, Intent(INOUT) :: Psection(:)

    Integer, Allocatable :: param_start(:)
    !! Starting sequence number of each entity in P section
    Integer, Allocatable :: param_end(:)
    !! Ending sequence number of each entity in P section

    Call makePrecs(PElist,     Psection, param_start, param_end)
    Call makeDrecs(DE, PElist, Dsection, param_start, param_end)

  End Subroutine makeDPsecPlist

  Subroutine makeDPsecParr(DE, PE, Dsection, Psection)
  !! Make the IGES output file D, and P sections from a Dentry array and
  !! an array of PE entities.  

    Type(Dentry_t), Allocatable, Intent(INOUT) :: DE(:)
    Type(PE_t),                  Intent(IN)    :: PE(:)
   
    Character(80),  Allocatable, Intent(INOUT) :: Dsection(:)
    Character(80),  Allocatable, Intent(INOUT) :: Psection(:)
    Integer, Allocatable :: param_start(:)
    !! Starting sequence number of each entity in P section
    Integer, Allocatable :: param_end(:)
    !! Ending sequence number of each entity in P section

    Call makePrecs(PE,     Psection, param_start, param_end)
    Call makeDrecs(DE, PE, Dsection, param_start, param_end)

  End Subroutine makeDPsecParr

  Subroutine makeGsection(G, Gsection)

    Type(Gsection_t),             Intent(INOUT) :: G
    Character(80),   Allocatable, Intent(INOUT) :: Gsection(:)

    Call G%makeGrecs(Gsection)

  End Subroutine makeGsection

  Subroutine makeSsection(Srecs, Ssection)
  !! Add sequence numbers to Srecs and return Ssection array if seq. numbers
  !! are not present in Srecs. Otherwise copy Srecs to Ssection

    Character(80),              Intent(IN)  :: Srecs(:)
    Character(80), Allocatable, Intent(OUT) :: Ssection(:)

    Integer :: i, numSrecs

    numSrecs = SIZE(Srecs)
    ALLOCATE(Ssection(numSrecs))

    If (Srecs(1)(73:73) /= "S") Then
      Do i=1, numSrecs
        Ssection(i) = Srecs(i)
        Write(Ssection(i)(73:73), '(A)') "S"
        Write(Ssection(i)(74:80), '(I7)') i
      End Do
    Else
      Do i=1, numSrecs
        Ssection(i) = Srecs(i)
      End Do
    End If
  End Subroutine makeSsection

  Subroutine writeIGESfile(filename, Ssection, Gsection, Dsection,      &
                           Psection)  

  !! Writes a complete IGES ASCII file given the file name, a Ssection array, 
  !! along a Gsection type, an array of Dentry_t values and a list of
  !! of PElist_t values. The Tsection record is created internally 

    Character(*),                  Intent(IN)    :: filename
    !! output file name
    Character(80),                 Intent(IN)    :: Ssection(:)
    !! A user specified S section array
    Character(80),                 Intent(IN)    :: Gsection(:)
    !! A user specified G section array
    Character(80),                 Intent(IN)    :: Dsection(:)
    !! A user specified D section array
    Character(80),                 Intent(IN)    :: Psection(:)
    !! A user specified P section array

    Character(80) :: Tsection

    Integer :: i, ounit
    Integer :: numSrecs, numGrecs, numDrecs, numPrecs

    numSrecs = SIZE(Ssection)
    numGrecs = SIZE(Gsection)
    numDrecs = SIZE(Dsection)
    numPrecs = SIZE(Psection)

    Open(newunit=ounit, FILE=TRIM(ADJUSTL(filename)), FORM="FORMATTED", &
         STATUS="UNKNOWN")

    Do i=1, numSrecs
      Write(ounit,'(A)') Ssection(i)
    End Do
    Do i=1, numGrecs
      Write(ounit,'(A)') Gsection(i)
    End Do
    Do i=1, numDrecs
      Write(ounit,'(A)') Dsection(i)
    End Do
    Do i=1, numPrecs
      Write(ounit,'(A)') Psection(i)
    End Do

    Call makeTsection(numSrecs, numGrecs, numDrecs, numPrecs, Tsection)

    Write(ounit,'(A)') Tsection

    Close(ounit)

  End Subroutine writeIGESfile

  Subroutine setPtmatForm(this)
  !! Sets the P entity type tmat and form components to the values in the
  !! corresponding Directory entry for. This is intended to provide a quick 
  !! backwards reference to a transformation matrix entity and to set the
  !! form number component. 

    Class(IGES_t),  Intent(INOUT) :: this
    !! IGES_T passed argument

    Integer :: i, tmat, form

! Set the PE entity tmat and form components to the values specified in the
! corresponding Directory Entry

    Do i=1,this%nentities

      tmat = this%D%DE(i)%transformation_matrix
      form = this%D%DE(i)%form_number

      this%P%PE(i)%entity%tmat = tmat
      this%P%PE(i)%entity%form = form

    End Do

  End Subroutine setPtmatForm

  Subroutine makePElist(this, Plist, entity_type)
  !! Makes a parameter entry list from the IGES_t P section PE array for
  !! either the entire IGES_T array or just the entities specified by
  !! the entity_type argument if present.
  
    Class(IGES_t),                    Intent(INOUT) :: this
    !! IGES_T passed argument
    Type(PElist_t), Optional, Target, Intent(INOUT) :: Plist
    !! Make output PList if present. Otherwise make the IGES_T Plist component
    Integer,        Optional,         Intent(IN)    :: entity_type
    !! Make a list of this entity type if present

! Copy the entire PE array of a IGES_T P section or just the values specified
! by the optional entity_type

    If (PRESENT(Plist)) Then
      If (PRESENT(entity_type)) Then
        Call copyParrayToList(this%P%PE, Plist, entity_type)
      Else 
        Call copyParrayToList(this%P%PE, Plist)
      End If
    Else
      Call copyParrayToList(this%P%PE, this%PEList)
    End If

  End Subroutine makePElist 

  Subroutine filterArraysByTypes(DE, PE, newDlist, newPlist, types)
  !! Given a DE and a PE array, filter out an array of  desired entity types
  !! (types) and create new DE and PE lists

    Type(Dentry_t),  Intent(INOUT) :: DE(:)
    !! Input DE array 
    Type(PE_t),      Intent(INOUT) :: PE(:)
    !! Input PE array 
    Type(DElist_t),  Intent(INOUT) :: newDlist
    !! Output new DE list
    Type(PElist_t),  Intent(INOUT) :: newPlist
    !! Output new PE list
    Integer,         Intent(IN)    :: types(:)
    !! Array of desired entity types

    Integer :: i, j, np, nd, entity_type

    Call newDlist%init()
    Call newPlist%init()

    nd = SIZE(DE) 
    np = SIZE(PE) 

    If (nd /= np) Then
      Write(stderr,*) ''
      ERROR STOP "filterArraysByTypes: Size of input DE and PE arrays are not the same"
    End If

! Get a desired type from DE Array 

    entity_type = 0
    Do i=1, nd
      entity_type = DE(i)%entity_type
      If (ANY(types == entity_type)) Then
        Call newDlist%append(DE(i))
      End If
    End Do 

! Get a desired type from PE list
 
    entity_type = 0
    Do i=1, np
      entity_type = PE(i)%entity%entity_type
      If (ANY(types == entity_type)) Then
        Call newPlist%append(PE(i)%entity)
      End If
    End Do
 
  End Subroutine filterArraysByTypes

  Subroutine filterArraysByType(DE, PE, newDlist, newPlist, etype)
  !! Given a DE and a PE array, filter out an array of  desired entity types
  !! (types) and create new DE and PE lists

    Type(Dentry_t),  Intent(INOUT) :: DE(:)
    !! Input DE array 
    Type(PE_t),      Intent(INOUT) :: PE(:)
    !! Input PE array 
    Type(DElist_t),  Intent(INOUT) :: newDlist
    !! Output new DE list
    Type(PElist_t),  Intent(INOUT) :: newPlist
    !! Output new PE list
    Integer,         Intent(IN)    :: etype
    !! Array of desired entity types

    Integer :: i, j, np, nd, entity_type

    Call newDlist%init()
    Call newPlist%init()

    nd = SIZE(DE) 
    np = SIZE(PE) 

    If (nd /= np) Then
      Write(stderr,*) ''
      ERROR STOP "filterArraysByTypes: Size of input DE and PE arrays are not the same"
    End If

! Get a desired type from DE Array 

    entity_type = 0
    Do i=1, nd
      entity_type = DE(i)%entity_type
      If (etype == entity_type) Then
        Call newDlist%append(DE(i))
      End If
    End Do 

! Get a desired type from PE list
 
    entity_type = 0
    Do i=1, np
      entity_type = PE(i)%entity%entity_type
      If (etype == entity_type) Then
        Call newPlist%append(PE(i)%entity)
      End If
    End Do
 
  End Subroutine filterArraysByType

  Subroutine filterListsByTypes(Dlist, Plist, newDlist, newPlist, types)
  !! Given a DE and a PE list, filter out an array of  desired entity types
  !! (types) and create new DE and PE lists

    Type(DElist_t),  Intent(INOUT) :: Dlist
    !! Input DE list
    Type(PElist_t),  Intent(INOUT) :: Plist
    !! Input PE list
    Type(DElist_t),  Intent(INOUT) :: newDlist
    !! Output new DE list
    Type(PElist_t),  Intent(INOUT) :: newPlist
    !! Output new PE list
    Integer,         Intent(IN)    :: types(:)
    !! Array of desired entity types

    Integer :: i, j, np, nd, entity_type

    Type(DEnode_t), Pointer :: DEnode
    Type(PEnode_t), Pointer :: PEnode

    Call newDlist%init()
    Call newPlist%init()

    nd = Dlist%size()
    np = Plist%size()

    If (nd /= np) Then
      Write(stderr,*) ''
      ERROR STOP "filterListByTypes: Size of input DE and PE lists are not the same"
    End If

! Get a desired type from DE list

    DEnode=>Dlist%first()
    entity_type = 0
    Do i=1, nd
      entity_type = DEnode%DE%entity_type
      If (ANY(types == entity_type)) Then
        Call newDlist%append(DEnode%DE)
      End If
      If (i < nd) Call Dlist%move(DEnode,1)
    End Do 

! Get a desired type from PE list
 
    PEnode => Plist%first()
    entity_type = 0
    Do i=1, np
      entity_type = PEnode%PE%entity_type
      If (ANY(types == entity_type)) Then
        Call newPlist%append(PEnode%PE)
      End If
      If (i < np) Call Plist%move(PEnode,1)
    End Do
 
  End Subroutine filterListsByTypes

  Subroutine filterListsByType(Dlist, Plist, newDlist, newPlist, etype)
  !! Given a DE and a PE list, filter out a desired entity type (etype) and
  !! create new DE and PE lists

    Type(DElist_t),  Intent(INOUT) :: Dlist
    !! Input DE list
    Type(PElist_t),  Intent(INOUT) :: Plist
    !! Input PE list
    Type(DElist_t),  Intent(INOUT) :: newDlist
    !! Output DE list
    Type(PElist_t),  Intent(INOUT) :: newPlist
    !! Output PE list
    Integer,         Intent(IN)    :: etype
    !! desired entity type

    Integer :: i, j, np, nd, entity_type

    Type(DEnode_t), Pointer :: DEnode
    Type(PEnode_t), Pointer :: PEnode

    Call newDlist%init()
    Call newPlist%init()

    nd = Dlist%size()
    np = Plist%size()

    If (nd /= np) Then
      Write(stderr,*) ''
      ERROR STOP "filterListByTypes: Size of input DE and PE lists are not the same"
    End If

! Get a desired type from DE list

    DEnode=>Dlist%first()
    entity_type = 0
    Do i=1, nd
      entity_type = DEnode%DE%entity_type
      If (etype == entity_type) Then
        Call newDlist%append(DEnode%DE)
      End If
      If (i < nd) Call Dlist%move(DEnode,1)
    End Do 

! Get a desired type from PE list
 
    PEnode => Plist%first()
    entity_type = 0
    Do i=1, np
      entity_type = PEnode%PE%entity_type
      If (etype == entity_type) Then
        Call newPlist%append(PEnode%PE)
      End If
      If (i < np) Call Plist%move(PEnode,1)
    End Do
 
  End Subroutine filterListsByType
 
  Subroutine copyParrayToList(PE, Plist, entity_type)
  !! Copy an array of P section entities to a list. Only copy values with
  !! an entity type number of entity_type if entity_type argument is present

    Type(PE_t),               Intent(IN)    :: PE(:)
    !! Input array of PE_t type values
    Type(PElist_t), Target,   Intent(INOUT) :: Plist
    !! Output PElist_t list
    Integer,        Optional, Intent(IN)    :: entity_type
 
    Integer :: i, np

! Initialize Plist and then copy either the entire PE array or just
! values specified by the optional entity_type

    np = SIZE(PE)
    Call Plist%init()

    If (PRESENT(entity_type)) Then
      Do i = 1, np
        If (PE(i)%entity%entity_type == entity_type) Then
          Call Plist%append(PE(i)%entity)
        End If
      End Do
    Else
      Do i = 1, np
        Call Plist%append(PE(i)%entity)
      End Do
    End If

  End Subroutine copyParrayToList

  Subroutine copyPlistToArray(Plist, PE)
  !! Copy a Parameter section list to an array

    Type(PElist_t), Target,      Intent(INOUT) :: Plist
    !! Input entity list
    Type(PE_t),     Allocatable, Intent(OUT)   :: PE(:)
    !! Output PE_t array

    Type(PEnode_t), Pointer :: node
    Type(entity0_t)         :: NULL

    Integer :: i, np


    np = Plist%size()

!! For a non-empty list copy list entities to a PE array

    If (np > 0) Then

      ALLOCATE(PE(np))
      node => Plist%first()

      Do i=1, np
        If (ASSOCIATED(node)) Then
          ALLOCATE(PE(i)%entity, SOURCE= node%PE)
        Else
          ALLOCATE(PE(i)%entity, SOURCE=NULL)
        End If 
        If (i < np) Call Plist%move(node,1)
      End Do
      If (ASSOCIATED(node)) NULLIFY(node)

    Else

      Write(stderr,*)''
      Write(stderr,*) ' *** forIGES WARNING ***'
      Write(stderr,'(" copyPlistToArray: Plist argument is an empty list")')

    End If

  End Subroutine copyPlistToArray

  Subroutine makeDElist(this, Dlist, entity_type)
  !! Make a Dentry_t list from the D section array for this IGES_t model and
  !! only include entities of with entity_type number when the entity_type
  !! optional argument is present

    Class(IGES_t),                    Intent(INOUT) :: this
    !! this IGES_T passed argument
    Type(DElist_t), Optional, Target, Intent(INOUT) :: Dlist
    !! Output List of type DElist_t if present. Otherwise, make the IGES_T
    !! Dlist component
    Integer,        Optional,         Intent(IN)    :: entity_type
    !! Only entries with entity_type number entity_type are included in the
    !! list when entity_type is present

! Copy either the entire D list or just values specified by the optional
! entity type 

    If (PRESENT(Dlist)) Then
      If (PRESENT(entity_type)) Then
        Call copyDarrayToList(this%D%DE, Dlist, entity_type)
      Else 
        Call copyDarrayToList(this%D%DE, Dlist)
      End If
    Else
      Call copyDarrayToList(this%D%DE, this%DElist)
    End If

  End Subroutine makeDElist 

  Subroutine copyDarrayToList(DE, Dlist, entity_type)
!! Copy a Dentry_t array to a list for all of the array values or just one
!! entity_type defined by the entity_type optional argument

    Type(Dentry_t),           Intent(IN)    :: DE(:)
    !! Input array of Dentry_t types
    Type(DElist_t), Target,   Intent(INOUT) :: Dlist
    !! Output list of Dentry_t values
    Integer,        Optional, Intent(IN)    :: entity_type
    !! Only copy entitites of this entity type number to the list 
 
    Integer :: i, nd

! Intialize D list and the copy either the entire DE array or just the
! enitity_type values 

    nd = SIZE(DE)
    Call Dlist%init()

    If (PRESENT(entity_type)) Then
      Do i = 1, nd
        If (DE(i)%entity_type == entity_type) Then
          Call Dlist%append(DE(i))
        End If
      End Do
    Else
      Do i = 1, nd
        Call Dlist%append(DE(i))
      End Do
    End If

  End Subroutine copyDarrayToList

  Subroutine copyDlistToArray(Dlist, DE)
  !! Copy a Dentry_t list to an array

    Type(DElist_t), Target,      Intent(INOUT) :: Dlist
    !! Input DE list
    Type(Dentry_t), Allocatable, Intent(OUT)   :: DE(:)
    !! Output Dentry_t array

    Type(DEnode_t), Pointer :: node
    Type(Dentry_t)          :: NULL

    Integer :: i, nd

    nd = Dlist%size()

! If not an empty list the allocate DE and use the initType method
! to copy a DE node from the list to the DE array

    If (nd > 0) Then

      ALLOCATE(DE(nd))
      node => Dlist%first()

      Do i=1, nd
        If (ASSOCIATED(node)) Then
          Call DE(i)%initType(node%DE) 
        Else
          Call DE(i)%initType(NULL)
        End If 
        If (i < nd) Call Dlist%move(node,1)
      End Do
      If (ASSOCIATED(node)) NULLIFY(node)

    Else

      Write(stderr,*)''
      Write(stderr,*) ' *** forIGES WARNING ***'
      Write(stderr,'(" copyDlistToArray: Dlist argument is an empty list")')

    End If

  End Subroutine copyDlistToArray

End Module forIGES
